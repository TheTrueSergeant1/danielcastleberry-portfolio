---
import MainLayout from '../layouts/MainLayout.astro';

// Frontmatter for this specific project page
const frontmatter = {
  title: "Prestige Rentals: A Secure Full-Stack Application",
  description: "An analysis of the secure architecture and defensive design behind a full-stack car rental system.",
  pubDate: "October 27, 2025"
};
---

<MainLayout title={frontmatter.title} description={frontmatter.description}>
  <article class="post-content">

    <header class="post-header bubble">
      <h1>{frontmatter.title}</h1>
      <p class="post-date">{frontmatter.pubDate}</p>
    </header>

    <section class="bubble" data-aos="fade-up">
      <h2>Project Overview</h2>
      <p>
        <strong>Prestige Rentals</strong> is a full-stack car rental web application that I designed and developed from the ground up. My primary objective was not only to create a functional platform but to architect it with <strong>security and resilience</strong> as core design principles. As a cybersecurity student, I approached this project as both a software engineer and a security analyst—prioritizing safe coding practices across every layer, from the database schema to the client-side logic.
      </p>
      <p>
        The platform serves two distinct roles: <strong>Customers</strong>, who can browse, rent, and review vehicles, and <strong>Administrators</strong>, who oversee fleet management, user accounts, and rental activity. Supporting these roles required a well-defined system for authentication, authorization, and data protection.
      </p>
    </section>

    <section class="bubble" data-aos="fade-up">
      <h2>How It Works: Core Functionality</h2>
      <p>
        The application is powered by a modular <strong>React (JSX) front end</strong> that communicates with a custom <strong>Node.js (Express)</strong> backend API and a <strong>MySQL database</strong> as the persistent data store.
      </p>

      <h3>The Customer Experience</h3>
      <p>
        Guests can explore the car catalog and apply filters to refine their search. To rent or interact with listings, users must first create an account. Once authenticated, they gain access to several key features:
      </p>
      <ul>
        <li><strong>Dashboard:</strong> A personalized dashboard for managing user profiles, saved vehicles, rental history, and payment options.</li>
        <li><strong>Rental Flow:</strong> A guided multi-step rental process that includes date selection, terms of service acknowledgment, optional add-ons, and payment confirmation.</li>
        <li><strong>Reviews:</strong> Verified renters can submit one review per vehicle and have full control to edit or delete their own feedback.</li>
      </ul>

      <h3>The Admin Panel</h3>
      <p>
        Administrators access a dedicated portal that grants elevated privileges through role-based API tokens. From here, staff can:
      </p>
      <ul>
        <li>Perform full <strong>CRUD (Create, Read, Update, Delete)</strong> operations on vehicle listings, customer records, and employee accounts.</li>
        <li>Manage maintenance schedules and monitor system-wide rental metrics.</li>
      </ul>
    </section>

    <section class="bubble" data-aos="fade-up">
    <h2>Database Features</h2>
    <p>
      The Prestige Rentals backend is designed with robust, secure, and highly functional features that support both business logic and cybersecurity best practices. Key capabilities of the system include:
    </p>

    <h3>Security & Server Setup</h3>
    <ul>
      <li>Secure HTTP Headers using <code>helmet</code>.</li>
      <li>CORS restricted to specific origins.</li>
      <li>Environment variables for sensitive data management.</li>
      <li>Rate limiting for login, registration, and password reset endpoints.</li>
      <li>Connection pooling to MySQL via <code>mysql2/promise</code>.</li>
    </ul>

    <h3>User & Employee Authentication</h3>
    <ul>
      <li>Employee and customer login endpoints.</li>
      <li>Customer registration with duplicate email checks.</li>
      <li>Password hashing using <code>bcrypt</code>.</li>
      <li>Password reset system using secure, expiring tokens.</li>
      <li>JWT-based authentication for admin and customer roles.</li>
      <li>Optional authentication for customizing public data access.</li>
    </ul>

    <h3>Public Data & Car Browsing</h3>
    <ul>
      <li>Endpoints for featured cars and testimonials.</li>
      <li>Listing of car types, features, and rental add-ons.</li>
      <li>Filter and search cars with type, make/model, and average rating.</li>
      <li>Fetch complete car details and reviews, including user-specific flags.</li>
    </ul>

    <h3>Customer Profile & Management (Authenticated)</h3>
    <ul>
      <li>View and update customer profile and password.</li>
      <li>Manage payment methods (add, list, delete) with ownership checks.</li>
      <li>Manage favorites (add, list, remove).</li>
      <li>Review system with eligibility checks and CRUD operations.</li>
      <li>Access to active and past rental history.</li>
    </ul>

    <h3>Rental Workflow (Authenticated)</h3>
    <ul>
      <li>Create rentals using database transactions for atomic operations.</li>
      <li>Calculate total cost including add-ons and duration.</li>
      <li>Return rentals safely with status updates and optional fees.</li>
      <li>Delete completed rentals along with associated payments and add-ons.</li>
    </ul>

    <h3>Admin Panel (Authenticated)</h3>
    <ul>
      <li>Dashboard metrics: car availability, revenue, and popular car types.</li>
      <li>CRUD operations for cars, employees, and customers.</li>
      <li>Maintenance management: schedule, complete, update costs, and history tracking.</li>
      <li>Force-return rentals and manage active maintenance records.</li>
    </ul>
  </section>

    <section class="bubble" data-aos="fade-up">
  <h2>Database & Backend Deep Dive</h2>
  <p>
    The backend of Prestige Rentals is designed around a <strong>relational MySQL database</strong>, which serves as the backbone for all persistent data. Every piece of data—from vehicle information to customer profiles—is stored in structured tables with clear relationships, allowing for consistent, safe, and efficient queries. Let’s break down the architecture and implementation.
  </p>

  <h3>1. Database Schema & Table Design</h3>
  <p>
    The schema models real-world entities, ensuring clarity and maintainability:
  </p>
  <ul>
    <li><strong>Customers:</strong> Stores essential user information including <code>customer_id</code>, <code>name</code>, <code>email</code>, <code>hashed_password</code>, <code>role</code>, and account status. Passwords are hashed using <code>bcrypt</code> before being stored to prevent compromise.</li>
    <li><strong>Cars:</strong> Maintains details about each vehicle, including <code>car_id</code>, <code>make</code>, <code>model</code>, <code>year</code>, <code>license_plate</code>, <code>availability_status</code>, and optional maintenance schedules.</li>
    <li><strong>Rentals:</strong> Maps customers to vehicles with <code>rental_id</code>, <code>customer_id</code>, <code>car_id</code>, <code>start_date</code>, <code>end_date</code>, <code>status</code>, and <code>total_price</code>.</li>
    <li><strong>Payments:</strong> Tracks payment transactions per rental, storing <code>payment_id</code>, <code>rental_id</code>, <code>amount</code>, <code>payment_method</code>, <code>timestamp</code>, and <code>status</code>.</li>
    <li><strong>Reviews:</strong> Connects customers to vehicles they’ve rented, with <code>review_id</code>, <code>customer_id</code>, <code>car_id</code>, <code>rating</code>, <code>comment</code>, and <code>created_at</code>. Each customer may submit only one review per vehicle.</li>
  </ul>

  <h3>2. Relationships & Referential Integrity</h3>
  <p>
    Proper relational mapping ensures data consistency:
  </p>
  <ul>
    <li><code>Rentals.customer_id → Customers.customer_id</code> (foreign key constraint enforces that every rental belongs to a valid customer).</li>
    <li><code>Rentals.car_id → Cars.car_id</code> (a rental must reference an existing car).</li>
    <li><code>Payments.rental_id → Rentals.rental_id</code> (payments are always linked to rentals).</li>
    <li><code>Reviews.customer_id → Customers.customer_id</code> and <code>Reviews.car_id → Cars.car_id</code> (reviews must belong to valid customers and cars).</li>
  </ul>
  <p>
    Using foreign keys enforces referential integrity, preventing orphaned records. Cascading rules, such as <code>ON DELETE CASCADE</code> for rentals and reviews, ensure that when a customer or vehicle is removed, related records are automatically cleaned up.
  </p>

  <h3>3. Indexing & Query Optimization</h3>
  <p>
    To support fast lookups and complex joins, I implemented indexing strategies:
  </p>
  <ul>
    <li>Primary keys automatically create unique indexes on <code>customer_id</code>, <code>car_id</code>, <code>rental_id</code>, etc.</li>
    <li>Secondary indexes on <code>email</code>, <code>license_plate</code>, and <code>start_date/end_date</code> optimize search queries and filter operations.</li>
    <li>Composite indexes on <code>customer_id, car_id</code> in <code>Rentals</code> improve performance for queries like "all rentals for a given customer" or "all rentals of a specific car."</li>
  </ul>

  <h3>4. SQL Queries & Parameterization</h3>
  <p>
    All SQL queries are implemented using <code>mysql2/promise</code> with parameterized statements to prevent SQL injection. Examples:
  </p>
  <ul>
    <li>
      <strong>Retrieve active rentals for a customer:</strong>
      <pre><code>SELECT r.rental_id, c.make, c.model, r.start_date, r.end_date
FROM Rentals r
JOIN Cars c ON r.car_id = c.car_id
WHERE r.customer_id = ? AND r.status = 'active';</code></pre>
    </li>
    <li>
      <strong>Create a new rental:</strong>
      <pre><code>INSERT INTO Rentals (customer_id, car_id, start_date, end_date, total_price)
VALUES (?, ?, ?, ?, ?);</code></pre>
    </li>
    <li>
      <strong>Update vehicle availability after rental:</strong>
      <pre><code>UPDATE Cars SET availability_status = 'unavailable' WHERE car_id = ?;</code></pre>
    </li>
  </ul>

  <h3>5. Transactions & Data Consistency</h3>
  <p>
    For multi-step operations like rental creation and payment processing, I use database transactions to ensure atomicity. This guarantees that either all steps complete successfully or none are applied, preventing inconsistent states. Example flow:
  </p>
  <ol>
    <li>Start transaction.</li>
    <li>Insert rental record.</li>
    <li>Insert payment record.</li>
    <li>Update car availability.</li>
    <li>Commit transaction if all succeed; otherwise, rollback.</li>
  </ol>

  <h3>6. Backend API & Integration</h3>
  <p>
    The backend exposes RESTful endpoints that abstract direct SQL operations, enforce validation, and provide secure data access:
  </p>
  <ul>
    <li><code>POST /api/rentals</code> – Creates a new rental, validates car availability, and initiates a transaction for payment and availability updates.</li>
    <li><code>GET /api/customers/:id/rentals</code> – Returns a customer’s rental history, joining <code>Rentals</code> with <code>Cars</code> for readable output.</li>
    <li><code>GET /api/admin/cars</code> – Provides admin-only vehicle management data, enforcing RBAC via middleware.</li>
    <li><code>POST /api/reviews</code> – Adds a review after verifying rental ownership, ensuring only verified customers can submit feedback.</li>
  </ul>

  <h3>7. Data Security & Privacy</h3>
  <p>
    Beyond SQL injection prevention, sensitive data such as passwords and payment information are never returned to the client. Query results are sanitized, and all data mutations are logged for auditing. User access is strictly controlled using JWTs and role-based middleware.
  </p>

  <p>
    This backend architecture provides a robust, secure, and scalable foundation for the rental website, supporting both business logic and cybersecurity best practices.
  </p>
</section>

<section class="bubble" data-aos="fade-up">
  <h2>Entity-Relationship (ER) Diagram</h2>
  <p>
    Below is a textual representation of the database schema in ER diagram format, detailing entities, weak entities, and relationships used in Prestige Rentals.
  </p>

  <h3>Entities (Strong Entities)</h3>
  <ul>
    <li><strong>Customers</strong>
      <ul>
        <li>Attributes: <u>customer_id</u> (PK), first_name, last_name, email, phone_number, address, city, state, zip_code, date_of_birth, password, reset_token, reset_token_expires</li>
      </ul>
    </li>
    <li><strong>Cars</strong>
      <ul>
        <li>Attributes: <u>car_id</u> (PK), make, model, year, license_plate, daily_rate, status, image_url, mileage, next_service_due_date, next_service_details, purchase_date, previous_owners, car_type_id (FK), location_id (FK)</li>
      </ul>
    </li>
    <li><strong>Employees</strong>
      <ul>
        <li>Attributes: <u>employee_id</u> (PK), first_name, last_name, job_title, hire_date, email, username, password</li>
      </ul>
    </li>
    <li><strong>Rentals</strong>
      <ul>
        <li>Attributes: <u>rental_id</u> (PK), customer_id (FK), car_id (FK), pickup_date, due_date, return_date, total_cost, late_fee</li>
      </ul>
    </li>
    <li><strong>Car_Types</strong>
      <ul>
        <li>Attributes: <u>car_type_id</u> (PK), type_name</li>
      </ul>
    </li>
    <li><strong>Locations</strong>
      <ul>
        <li>Attributes: <u>location_id</u> (PK), name, address</li>
      </ul>
    </li>
    <li><strong>Addons</strong>
      <ul>
        <li>Attributes: <u>addon_id</u> (PK), name, description, price</li>
      </ul>
    </li>
    <li><strong>Features</strong>
      <ul>
        <li>Attributes: <u>feature_id</u> (PK), name</li>
      </ul>
    </li>
  </ul>

  <h3>Weak Entities</h3>
  <ul>
    <li><strong>Payments</strong> – existence dependent on Rentals
      <ul>
        <li>Attributes: <u>payment_id</u> (PK), rental_id (FK), amount, payment_date, payment_method</li>
      </ul>
    </li>
    <li><strong>Maintenance</strong> – existence dependent on Cars
      <ul>
        <li>Attributes: <u>maintenance_id</u> (PK), car_id (FK), service_date, service_type, cost, notes, completion_date</li>
      </ul>
    </li>
    <li><strong>CustomerPaymentMethods</strong> – existence dependent on Customers
      <ul>
        <li>Attributes: <u>payment_method_id</u> (PK), customer_id (FK), card_holder_name, card_type, masked_number, expiry_date, is_primary</li>
      </ul>
    </li>
    <li><strong>Reviews</strong> – existence dependent on Customers and Cars
      <ul>
        <li>Attributes: <u>review_id</u> (PK), car_id (FK), customer_id (FK), rating, review_text, review_date</li>
      </ul>
    </li>
  </ul>

  <h3>Relationships</h3>
  <ul>
    <li><strong>books</strong> – connects Customers to Rentals (1:N)</li>
    <li><strong>is_for</strong> – connects Rentals to Cars (N:1)</li>
    <li><strong>is_type_of</strong> – connects Cars to Car_Types (N:1)</li>
    <li><strong>is_parked_at</strong> – connects Cars to Locations (N:1)</li>
    <li><strong>favorites</strong> – connects Customers to Cars (N:M)</li>
    <li><strong>has_features</strong> – connects Cars to Features (N:M)</li>
    <li><strong>includes_addons</strong> – connects Rentals to Addons (N:M)</li>
  </ul>

  <h3>Identifying Relationships (for Weak Entities)</h3>
  <ul>
    <li><strong>generates</strong> – Rentals to Payments (1:N)</li>
    <li><strong>undergoes</strong> – Cars to Maintenance (1:N)</li>
    <li><strong>has_method</strong> – Customers to CustomerPaymentMethods (1:N)</li>
    <li><strong>writes_review</strong> – Customers to Reviews (1:N)</li>
    <li><strong>receives_review</strong> – Cars to Reviews (1:N)</li>
  </ul>
</section>

    <section class="bubble" data-aos="fade-up">
      <h2>Cybersecurity Implementation: A Defensive Deep Dive</h2>
      <p>
        Security was the guiding principle behind every architectural decision. Drawing from my coursework and practical labs, I implemented multiple layers of defense to mitigate common web application vulnerabilities.
      </p>

      <h3>1. Authentication & Session Management</h3>
      <ul>
        <li><strong>Password Hashing:</strong> User passwords are never stored in plaintext. Using <code>bcrypt</code>, each password is hashed with a unique salt to defend against rainbow table and dictionary attacks.</li>
        <li><strong>JSON Web Tokens (JWT):</strong> Upon successful login, the server issues a signed, stateless JWT containing the user’s ID and role. This token is stored in <code>sessionStorage</code> and attached to all subsequent requests via the <code>Authorization</code> header.</li>
      </ul>

      <h3>2. Authorization & Access Control</h3>
      <p>
        Authentication verifies identity, but authorization enforces boundaries. I implemented <strong>Role-Based Access Control (RBAC)</strong> using Express middleware.
      </p>
      <ul>
        <li><strong>Middleware Validation:</strong> Two custom middleware functions—<code>authenticateCustomer</code> and <code>authenticateAdmin</code>—validate JWTs and confirm user roles before granting access.</li>
        <li><strong>Route Protection:</strong> Administrative routes (e.g., <code>/api/admin/cars</code>) are restricted to valid admin tokens. Any unauthorized request receives an immediate <code>403 Forbidden</code> response.</li>
      </ul>

      <h3>3. Mitigating Common Vulnerabilities</h3>
      <ul>
        <li><strong>SQL Injection:</strong> All database queries use <code>mysql2/promise</code> with parameterized queries, ensuring user input is treated strictly as data and not executable SQL code.</li>
        <li><strong>Brute-Force Protection:</strong> The authentication endpoints employ <code>express-rate-limit</code> to throttle repeated failed login attempts, mitigating automated password guessing attacks.</li>
        <li><strong>HTTP Header Hardening:</strong> <code>helmet.js</code> is configured to enforce headers like <code>Strict-Transport-Security</code>, <code>X-Frame-Options</code>, and <code>X-Content-Type-Options</code>, reducing exposure to clickjacking and MIME-sniffing exploits.</li>
        <li><strong>Cross-Origin Resource Sharing (CORS):</strong> The backend only accepts requests from whitelisted origins, preventing malicious cross-domain API calls.</li>
      </ul>

      <h3>4. Secure API & Data Handling</h3>
      <ul>
        <li><strong>Data Ownership Verification:</strong> Before performing destructive actions (e.g., deleting reviews or payment methods), the backend validates ownership by matching the resource’s user ID against the ID from the verified JWT.</li>
        <li><strong>Response Sanitization:</strong> All user-facing responses are scrubbed of sensitive data such as password hashes and tokens before being returned to the client.</li>
      </ul>
    </section>

    <section class="bubble" data-aos="fade-up">
      <h2>Technology Stack</h2>
      <ul>
        <li><strong>Frontend:</strong> React (JSX), Astro, Tailwind CSS, Framer Motion</li>
        <li><strong>Backend:</strong> Node.js, Express.js</li>
        <li><strong>Database:</strong> MySQL with <code>mysql2/promise</code></li>
        <li><strong>Security & Auth:</strong> JSON Web Tokens (JWT), <code>bcrypt</code>, <code>helmet.js</code>, <code>express-rate-limit</code>, <code>cors</code></li>
      </ul>
    </section>

    <section class="bubble" data-aos="fade-up">
      <h2>What I Learned</h2>
      <p>
        Developing Prestige Rentals was an opportunity to bridge theory and practice in secure software design. Concepts like SQL injection, rate limiting, and RBAC moved from abstract lessons to real-world implementations that I could test and validate.
      </p>
      <p>
        This project reinforced the mindset of building defensively—never trusting client input, always validating on the server, and designing APIs to minimize exposure. It deepened my understanding of how security is not a single feature, but a process integrated throughout the software lifecycle.
      </p>
    </section>

  </article>
</MainLayout>

<style>
.post-content {
  max-width: 900px;
  margin: 2rem auto;
  display: flex;
  flex-direction: column;
  gap: 2rem;
}

.bubble {
  background: var(--glass-bg);
  backdrop-filter: blur(12px);
  border-radius: 2rem;
  border: 1px solid var(--border-color);
  padding: 2rem;
  line-height: 1.7;
  box-shadow: 0 8px 20px rgba(0,0,0,0.2);
}

.post-header h1 {
  color: var(--accent-color);
  font-size: 2.5rem;
  margin-bottom: 0.3rem;
}

.post-date {
  font-size: 0.9rem;
  color: #aab2bb;
}

h2 {
  color: var(--accent-color);
  font-size: 1.8rem;
  margin-bottom: 1rem;
}

h3 {
  font-size: 1.4rem;
  font-weight: 600;
  color: var(--text-color-light);
  margin-top: 1.5rem;
  margin-bottom: 0.75rem;
  border-bottom: 1px solid var(--border-color);
  padding-bottom: 0.25rem;
}

p, ul {
  color: var(--text-color);
  font-size: 1rem;
  margin-bottom: 0.75rem;
}

ul {
  list-style-position: inside;
  list-style-type: disc;
  padding-left: 1rem;
}

li {
  margin-bottom: 0.5rem;
}

@media (max-width: 768px) {
  .post-content {
    padding: 1rem;
    gap: 1rem;
  }
  .bubble {
    padding: 1.5rem;
  }
  h1 { font-size: 2rem; }
  h2 { font-size: 1.4rem; }
  h3 { font-size: 1.2rem; }
}
</style>
